<!DOCTYPE html>
<html>
    <head>
        <script src="//treetopflyer.github.com/vcore/lib.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
        <style>
body
{
    margin:100px;
    background:#aaa;    
}
.Graph
{
    position:relative;
    float:left;
    border:1px solid #000;
    
    perspective:500px;
    transform-style: preserve-3d;
}    
.Graph > .Center
{
    position:absolute;
    width:100%;
    height:100%;
    top:0%;
    left:0%;
    border:1px solid #000;
    
    transform-style: preserve-3d;
    transform:rotateY(0deg);
}

.Graph .Point
{
    position:absolute;
    width:1px;
    height:1px;
    
    transform-style: preserve-3d;
    transform:translate3d(0, 0, 0);
}
.Graph .Point > .Fill
{
    position:absolute;
    top:-5px;
    left:-5px;
    width:10px;
    height:10px;
    background:rgb(255, 0, 0);
    /*border:1px solid #fff;*/
    border-radius:10px;
    
    transform-style: preserve-3d; 
    transform:rotateY(0deg);
}
        </style>
    </head>
    <body>
        <script>
            
var Graph = {};
Graph.Create = function(inJQParent)
{
    var obj = {};
    obj.Size = 300;

    obj.Rotate = function(inAngle)
    {
        obj.JQ.Center.css({"transform":"rotateY("+inAngle+"deg)"});
        obj.JQ.Centers.css({"transform":"rotateY("+(-inAngle)+"deg)"});
    };

    obj.JQ = {};
    obj.JQ.Graph = $("<div class=\"Graph\" style=\"width:"+obj.Size+"px; height:"+obj.Size+"px;\"></div>");
    obj.JQ.Center = $("<div class=\"Center\"></div>");
    obj.JQ.Graph.append(obj.JQ.Center);
    obj.JQ.Points = $();
    obj.JQ.Centers = $();
    
    obj.MapColor = function(inColor)
    {
        if(inColor[2] === undefined)
            inColor[2] = 0;
        
        if(inColor[1] === undefined)
            inColor[1] = 0;
            
        return "rgb("+(inColor[0]*255)+", "+(inColor[1]*255)+", "+(inColor[2]*255)+")";
    };
    
    obj.MapPosition = function(inPos)
    {
        if(inPos[2] === undefined)
            inPos[2] = 0;
        
        if(inPos[1] === undefined)
            inPos[1] = 0;
            
        return "translate3d("+(inPos[0]*obj.Size)+"px, "+(inPos[1]*obj.Size)+"px, "+(inPos[2]*obj.Size)+"px)";
    };
    
    obj.Point = function(inPos, inColor)
    {
        var jqPoint = $("<div class=\"Point\" style=\"transform:"+obj.MapPosition(inPos)+";\"></div>");
        var jqCenter = $("<div class=\"Fill\" style=\"background:"+obj.MapColor(inColor)+";\"></div>");
        jqPoint.append(jqCenter);
        
        obj.JQ.Points = obj.JQ.Points.add(jqPoint);
        obj.JQ.Centers = obj.JQ.Centers.add(jqCenter);
        
        obj.JQ.Center.append(jqPoint);
    };

    obj.Points = function(inTrainingSet)
    {
          var i;
          for(i=0; i<inTrainingSet.Order.length; i++)
          {
              obj.Point(V.Clone(inTrainingSet.Input[i]), V.Clone(inTrainingSet.Output[i]));
          }
    };
    
    obj.Move = function(inMatrix)
    {
        var i;
        var pos;
        for(i=0; i<inMatrix.length; i++)
        {
            css = obj.MapPosition(V.Clone(inMatrix[i]));
            obj.JQ.Points.eq(i).css({"transform":css});
        } 
    };
    
    inJQParent.append(obj.JQ.Graph);
 
    return obj;   
}
        </script>
        <script>
            
var NN = {};

NN.TrainingSet = {};
NN.TrainingSet.Instances = [];
NN.TrainingSet.Create = function()
{
    var obj = {};

    obj.Input = [];
    obj.Output = [];
    obj.Order = [];
    
    NN.TrainingSet.Instances.push(obj);
    return obj;
};

NN.TrainingSet.Add = function(inTrainingSet, inType, inData)
{
    inTrainingSet.Input.push(inData);
    inTrainingSet.Output.push(inType);
    inTrainingSet.Order.push(inTrainingSet.Order.length);
};
NN.TrainingSet.AddCloud = function(inTrainingSet, inLabel, inCloud)
{
    var i;
    for(i=0; i<inCloud.length; i++)
    {
        NN.TrainingSet.Add(inTrainingSet, inLabel, inCloud[i]);
    }
};
NN.TrainingSet.Randomize = function(inTrainingSet)
{
      var newOrder = [];
      var selection;
      while(inTrainingSet.Order.length != 0)
      {
          selection = Math.floor(inTrainingSet.Order.length * Math.random());
          inTrainingSet.Order.splice(selection, 1);
          newOrder.push(selection);
      }
      inTrainingSet.Order = newOrder;
};


NN.Playback = {};
NN.Playback.Create = function()
{
    var obj = {};
    obj = {};
    obj.Frames = [];
    obj.Capture = function(inNetwork)
    {
        var i;
        var frame = [];
        for(i=0; i<inNetwork.Layers.length; i++)
        {
            frame.push(inNetwork.Layers[i].Forward.Matrix);
        }
        obj.Frames.push(frame);
    };
    return obj;
};

NN.Network = {};
NN.Network.Instances = [];
NN.Network.Create = function()
{
    var obj = {};
    var i;    
    
    obj.Layers = [];
    obj.LearningRate = 0.1;
    obj.Error = [];
    
    for(i=0; i<arguments.length-1; i++)
    {
        obj.Layers.push(NN.Layer.Create(arguments[i], arguments[i+1]));
    }
    
    NN.Network.Instances.push(obj);
    return obj;
};
NN.Network.Observe = function(inNetwork, inBatch)
{
      var input = inBatch;
      var i;
      for(i=0; i<inNetwork.Layers.length; i++)
      {
          input = NN.Layer.Forward(inNetwork.Layers[i], input);
      }
      return inNetwork.Layers[inNetwork.Layers.length-1].Forward.StageSigmoid;
};
NN.Network.Error = function(inNetwork, inTraining)
{
      return M.Subtract(inNetwork.Layers[inNetwork.Layers.length-1].Forward.StageSigmoid, inTraining);
};
NN.Network.Learn = function(inNetwork, inError)
{
      var input = inError;
      var i;
      for(i=inNetwork.Layers.length-1; i>=0; i--)
      {
          input = NN.Layer.Backward(inNetwork.Layers[i], input);
          NN.Layer.Adjust(inNetwork.Layers[i], inNetwork.LearningRate);
      }
};


NN.Network.Batch = function(inNetwork, inTrainingSet, inIterations)
{
    var i;
    for(i=0; i<inIterations; i++)
    {
        NN.Network.Observe(inNetwork, inTrainingSet.Input);
        inNetwork.Error = NN.Network.Error(inNetwork, inTrainingSet.Output)
        NN.Network.Learn(inNetwork, inNetwork.Error);
    }
};
NN.Network.Stochastic = function(inNetwork, inTrainingSet, inIterations)
{
    var i, j;
    var current;
    
    var playback = NN.Playback.Create();
    
    for(i=0; i<inIterations; i++)
    {
        NN.TrainingSet.Randomize(inTrainingSet);
        for(j=0; j<inTrainingSet.Order.length; j++)
        {
            //playback.Capture(inNetwork);
            current = inTrainingSet.Order[j];
            NN.Network.Observe(inNetwork, [inTrainingSet.Input[current]]);
            inNetwork.Error = NN.Network.Error(inNetwork, [inTrainingSet.Output[current]]);
            NN.Network.Learn(inNetwork, inNetwork.Error);
        }
    }
    //playback.Capture(inNetwork);
    //return playback;
    
};



NN.Layer = {};
NN.Layer.Create = function(sizeIn, sizeOut)
{
    var i;
    var min = [];
    var max = [];
    var obj = {};
    
    sizeIn++;
    
    obj.Forward = {};
    for(i=0; i<sizeIn; i++)
    {
        min.push(-1);
        max.push(1);
    }
    obj.Forward.Matrix = M.Box([min, max], sizeOut);
    obj.Forward.StageInput = [];
    obj.Forward.StageAffine = [];
    obj.Forward.StageSigmoid = [];
    obj.Forward.StageDerivative = [];
    
    obj.Backward = {};
    obj.Backward.Matrix = M.Transpose(obj.Forward.Matrix);
    obj.Backward.StageInput = [];
    obj.Backward.StageDerivative = [];
    obj.Backward.StageAffine = [];
    
    return obj;
};
NN.Layer.Forward = function(inLayer, inInput)
{
    inLayer.Forward.StageInput = M.Pad(M.Clone(inInput)); // Pad the input
    inLayer.Forward.StageAffine = M.Transform(inLayer.Forward.Matrix, inLayer.Forward.StageInput);
    inLayer.Forward.StageSigmoid = M.Sigmoid(inLayer.Forward.StageAffine);
    
    return inLayer.Forward.StageSigmoid;
};
NN.Layer.Error = function(inLayer, inTarget)
{
    return M.Subtract(inLayer.Forward.StageSigmoid, inTarget);
};
NN.Layer.Backward = function(inLayer, inInput)
{
    /* We need the derivative of the forward pass, but only during the backward pass.
    That's why-- even though it "belongs" to the forward pass-- it is being calculated here. */
    inLayer.Forward.StageDerivative = M.Derivative(inLayer.Forward.StageSigmoid);
    
    /* This transpose matrix is for sending the error back to a previous layer.
    And again, even though it is derived directly from the forward matrix, it is only needed during the backward pass so we calculate it here.*/
    inLayer.Backward.Matrix = M.Transpose(inLayer.Forward.Matrix);
    


    /* When the error vector arrives at a layer, it always needs to be multiplied (read 'supressed') by the derivative of
    what the layer output earlier during the forward pass.
    So despite its name, Backward.StageDerivative contains the result of this *multiplication* and not some new derivative calculation.*/
    inLayer.Backward.StageInput = inInput;
    inLayer.Backward.StageDerivative = M.Multiply(inLayer.Backward.StageInput, inLayer.Forward.StageDerivative);
    inLayer.Backward.StageAffine = M.Transform(inLayer.Backward.Matrix, inLayer.Backward.StageDerivative);
    
    return M.Unpad(inLayer.Backward.StageAffine);// Unpad the output
};
NN.Layer.Adjust = function(inLayer, inLearningRate)
{
    var deltas;
    var vector;
    var scalar;
    var batchSize = inLayer.Forward.StageInput.length;
    var i, j;
    
    for(i=0; i<batchSize; i++)
    {
        deltas = [];
        
        /* For the Ith vector in the batch... */
        vector = inLayer.Forward.StageInput[i];
        for(j=0; j<inLayer.Forward.Matrix.length; j++)
        {
            /* Change the Jth member of Forward.Matrix by:
            the Ith input vector, multiplied by the Jth component of the Ith Backward.StageDerivative (the input error times the output derivative, pre-calculated above),
            factoring in the learning rate and batch size */
            deltas[j] = V.Scale(vector, (inLayer.Backward.StageDerivative[i][j] * inLearningRate) / batchSize);
        }
        
        inLayer.Forward.Matrix = M.Subtract(inLayer.Forward.Matrix, deltas);
    }
};
NN.Layer.Stochastic = function(inLayer, inTrainingSet, inIterations)
{
    /* this method is ONLY for testing individual layers, and does not translate to network-level training */
    var i, j;
    var current;
    var error;
    for(i=0; i<inIterations; i++)
    {
        NN.TrainingSet.Randomize(inTrainingSet);
        for(j=0; j<inTrainingSet.Order.length; j++)
        {
            current = inTrainingSet.Order[j];
            NN.Layer.Forward(inLayer, [inTrainingSet.Input[current]]);
            error = M.Subtract(inLayer.Forward.StageSigmoid, [inTrainingSet.Output[current]]);
            NN.Layer.Backward(inLayer, error);
            NN.Layer.Adjust(inLayer, 0.1);
        }
    }
};


        </script>
        <script>

var ts1 = NN.TrainingSet.Create();

NN.TrainingSet.AddCloud(ts1, [1], M.Box([[0, 0], [0.4, 1.0]], 5));// black upright
NN.TrainingSet.AddCloud(ts1, [1], M.Box([[0, 1], [1.5, 1.4]], 5));

NN.TrainingSet.AddCloud(ts1, [0], M.Box([[0.8, 0], [1.0, 0.7]], 5));
NN.TrainingSet.AddCloud(ts1, [0], M.Box([[0, -0.3], [1.0, -0.1]], 5));

NN.TrainingSet.AddCloud(ts1, [0], M.Box([[0, 1.5], [1.0, 1.8]], 5));


ts1.Input = M.GlobalToLocal(ts1.Input, M.Bounds(ts1.Input));

var n1 = NN.Network.Create(2, 10, 4, 1);
n1.LearningRate = 0.2;
var pb1 = NN.Network.Batch(n1, ts1, 20000);
NN.Network.Observe(n1, ts1.Input);

var g1 = Graph.Create($("body"));
g1.Points(ts1);

/*
var g2a = Graph.Create($("body"));
g2a.Points(ts1);
g2a.Move(M.GlobalToLocal(n1.Layers[0].Forward.StageAffine, M.Bounds(n1.Layers[0].Forward.StageAffine)));
*/

/*
var g2b = Graph.Create($("body"));
g2b.Points(ts1);
g2b.Move(n1.Layers[0].Forward.StageSigmoid);
*/

/*
var g3a = Graph.Create($("body"));
g3a.Points(ts1);
g3a.Move(M.GlobalToLocal(n1.Layers[1].Forward.StageAffine, M.Bounds(n1.Layers[1].Forward.StageAffine)));
*/

var g3b = Graph.Create($("body"));
g3b.Points(ts1);
g3b.Move(n1.Layers[2].Forward.StageSigmoid);


/*
var g4 = Graph.Create($("body"));
g4.Points(ts1);
g4.Move(n1.Layers[2].Forward.StageSigmoid);
*/

        </script>
    </body>
</html>